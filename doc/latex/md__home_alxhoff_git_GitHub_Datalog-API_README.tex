{\itshape windows users you are on your own}

\subsection*{Introduction}

The original implementation of the L\+U\+A/C library is not the easiest to work with and does not lead to logical or easy to follow code. I have quickly thrown this A\+PI together to make the coding datalog coding style similar to that of the Python implementation.

\subsection*{Prerequisites}

The L\+U\+A/C library can be found \href{http://datalog.sourceforge.net}{\tt here} and must be downlaoded and placed into the libs folder such that the file tree looks like this 
\begin{DoxyCode}
|--- Datalog-API  
      |  
      |---bin  
      |---build  
      |---doc  
      |  
      |---libs  
           |---libdatalog <---rename downloaded folder to this  
               |---source files  
               |---lua  
                    |---lua source files  
\end{DoxyCode}
 \subsection*{Building}

I have included a demo \hyperlink{main_8c}{main.\+c} as well as a demo C\+Make that will build the A\+PI as a shared library that can then be linked into an exsisting project.

\subsubsection*{How to build}

It\textquotesingle{}s pretty tough.... cd into the root director and create a build dir, or don\textquotesingle{}t, it\textquotesingle{}ll be your mess.


\begin{DoxyCode}
cd Datalog-API
mkdir build
cd build
\end{DoxyCode}
 Generate C\+Make junk {\bfseries or} run ccmake to configure debugging options 
\begin{DoxyCode}
cmake ..
\end{DoxyCode}
 {\bfseries or} 
\begin{DoxyCode}
ccmake ..
\end{DoxyCode}
 and finally make 
\begin{DoxyCode}
make
\end{DoxyCode}
 The executable can be found in the bin subdirectory in the root dir.

Library objects in the build subdirectory.

\subsection*{Documentation}

To generate the documentation run the command


\begin{DoxyCode}
doxygen
\end{DoxyCode}
 from the doc folder. Then navigate to ./html/index.html

\subsection*{Work in progress}

I wrote this quickly and dirtily, so excuse the mess.

\subsubsection*{To-\/\+Do}


\begin{DoxyItemize}
\item Fix demo project
\item Integrate parser into A\+PI
\item $\sim$$\sim$\+Clauses with bodies$\sim$$\sim$
\item Error checking on literal types
\item Check that all methods are implemented for all objects, both with and without structs.
\item Lots more stuff I am to yet to discover
\end{DoxyItemize}

\subsection*{Objects}

The A\+PI revolves around a struct objects to enable a more logical way or representing datalog commands rather than the push and pop confusion found in the library.

Literals are represented by the object {\bfseries datalog\+\_\+literal\+\_\+t}, queries by {\bfseries datalog\+\_\+query\+\_\+t} and clauses by {\bfseries datalog\+\_\+clause\+\_\+t}. I may of missed a few methods to be implemented but I should get these done as I actually use this A\+PI for other code.

\section*{X\+ML Parser (very Beta)}

he X\+ML parser is designed to be used to be able to generate or create X\+ML files that can then be parsed to a datalog program to load rules and facts into the datalog database. The parser is built around libxml2 and I built the C\+Make to use stand alone libraries so to ensure easier building. The parser works by calling the dl\+\_\+parser\+\_\+init function, specifying the file to be opened. This will initialise the document object used by the parser.

\subsection*{Literal objects}

The parser represents literals using the dl\+\_\+parser\+\_\+literal\+\_\+t object that stores the predicate and arguments for the literal. Literals are probably not used directly in the parser.

\subsection*{Fact objects}

A fact in Datalog is a clause without a body, aka it\textquotesingle{}s a standard literal. Facts are essentailly a literal stored in a container allowing them to be used as elements of a linked list as well as storing a reference to the X\+ML node that corresponds to the fact. The parser will scan the entire document for facts, creating a linked list. This linked list is then traversed and each X\+ML fact node is walked and processed so that each fact is represented by a dl\+\_\+parser\+\_\+fact\+\_\+t object which contains the fact\textquotesingle{}s literal.

The facts in the X\+ML tree can be found by calling dl\+\_\+parser\+\_\+mappings as this will in turn walk the X\+ML tree and call dl\+\_\+parser\+\_\+add\+\_\+fact on all found facts. Found facts are then processed using dl\+\_\+parser\+\_\+process\+\_\+fact. After processing the found facts can be found pointed to by the linked list head pointer dl\+\_\+parser\+\_\+fact\+\_\+t$\ast$ facts\+\_\+head found within the dl\+\_\+parser\+\_\+doc\+\_\+t object.

\subsection*{Rule objects}

In Datalog rules are clauses that contain a body, the body being a potentially infinite length array of literals. In the X\+ML parser rules are represented similarly to facts, using the dl\+\_\+parser\+\_\+rule\+\_\+t object, with the exception that the rules object represents the body of the rule by an array of literal pointers. This list is dynamically allocated to allow for potentially infinite length rules. Parsing of rules happens in the same fashion as facts, in that a call to dl\+\_\+parser\+\_\+mappings will walk the X\+ML tree and call dl\+\_\+parser\+\_\+add\+\_\+rule on any found rules. These are then stores in a similar linked list fashion and processed through calls to dl\+\_\+parser\+\_\+process\+\_\+rule whilst iterating over the linked list. The linked list of processed rules can be found using the head pointer dl\+\_\+parser\+\_\+rule\+\_\+t$\ast$ rules\+\_\+head found in the dl\+\_\+parser\+\_\+doc\+\_\+t object.

\subsection*{Parser use}

Parser use should pretty much only require the user to call


\begin{DoxyCode}
\hyperlink{structdl__parser__doc}{dl\_parser\_doc\_t}* dl\_doc = \hyperlink{datalog__parser_8c_a60bfcc264ca417a3c86c24d83775126a}{dl\_parser\_init}(filename);
\end{DoxyCode}
 followed by 
\begin{DoxyCode}
\hyperlink{datalog__parser_8c_a83e01ba37291311f7b45d9eaa89bfd77}{dl\_parser\_mappings}(dl\_doc);
\end{DoxyCode}


but one can also print any number of the objects in the library though the number of print functions. Document metadata can also be parsed by calling \hyperlink{structdl__parser__metadata}{dl\+\_\+parser\+\_\+metadata} which will populat a dl\+\_\+parser\+\_\+metadata\+\_\+t object stored in the main dl\+\_\+parser\+\_\+doc\+\_\+t object. See included example for furthur usage. 