<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Datalog API: Datalog API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Datalog API
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Datalog API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><em>windows users you are on your own</em></p>
<h2>Introduction</h2>
<p>The original implementation of the LUA/C library is not the easiest to work with and does not lead to logical or easy to follow code. I have quickly thrown this API together to make the coding datalog coding style similar to that of the Python implementation.</p>
<h2>Prerequisites</h2>
<p>The LUA/C library can be found <a href="http://datalog.sourceforge.net">here</a> and must be downlaoded and placed into the libs folder such that the file tree looks like this </p><div class="fragment"><div class="line">|--- Datalog-API  </div><div class="line">      |  </div><div class="line">      |---bin  </div><div class="line">      |---build  </div><div class="line">      |---doc  </div><div class="line">      |  </div><div class="line">      |---libs  </div><div class="line">           |---libdatalog &lt;---rename downloaded folder to this  </div><div class="line">               |---source files  </div><div class="line">               |---lua  </div><div class="line">                    |---lua source files  </div></div><!-- fragment --> <h2>Building</h2>
<p>I have included a demo <a class="el" href="main_8c.html" title="Demo main.c for Datalog API. ">main.c</a> as well as a demo CMake that will build the API as a shared library that can then be linked into an exsisting project.</p>
<h3>How to build</h3>
<p>It's pretty tough.... cd into the root director and create a build dir, or don't, it'll be your mess.</p>
<div class="fragment"><div class="line">cd Datalog-API</div><div class="line">mkdir build</div><div class="line">cd build</div></div><!-- fragment --><p> Generate CMake junk <b>or</b> run ccmake to configure debugging options </p><div class="fragment"><div class="line">cmake ..</div></div><!-- fragment --><p> <b>or</b> </p><div class="fragment"><div class="line">ccmake ..</div></div><!-- fragment --><p> and finally make </p><div class="fragment"><div class="line">make</div></div><!-- fragment --><p> The executable can be found in the bin subdirectory in the root dir.</p>
<p>Library objects in the build subdirectory.</p>
<h2>Documentation</h2>
<p>To generate the documentation run the command</p>
<div class="fragment"><div class="line">doxygen</div></div><!-- fragment --><p> from the doc folder. Then navigate to ./html/index.html</p>
<h2>Work in progress</h2>
<p>I wrote this quickly and dirtily, so excuse the mess.</p>
<h3>To-Do</h3>
<ul>
<li>Fix demo project</li>
<li>Integrate parser into API</li>
<li>~~Clauses with bodies~~</li>
<li>Error checking on literal types</li>
<li>Check that all methods are implemented for all objects, both with and without structs.</li>
<li>Lots more stuff I am to yet to discover</li>
</ul>
<h2>Objects</h2>
<p>The API revolves around a struct objects to enable a more logical way or representing datalog commands rather than the push and pop confusion found in the library.</p>
<p>Literals are represented by the object <b>datalog_literal_t</b>, queries by <b>datalog_query_t</b> and clauses by <b>datalog_clause_t</b>. I may of missed a few methods to be implemented but I should get these done as I actually use this API for other code.</p>
<h1>XML Parser (very Beta)</h1>
<p>he XML parser is designed to be used to be able to generate or create XML files that can then be parsed to a datalog program to load rules and facts into the datalog database. The parser is built around libxml2 and I built the CMake to use stand alone libraries so to ensure easier building. The parser works by calling the dl_parser_init function, specifying the file to be opened. This will initialise the document object used by the parser.</p>
<h2>Literal objects</h2>
<p>The parser represents literals using the dl_parser_literal_t object that stores the predicate and arguments for the literal. Literals are probably not used directly in the parser.</p>
<h2>Fact objects</h2>
<p>A fact in Datalog is a clause without a body, aka it's a standard literal. Facts are essentailly a literal stored in a container allowing them to be used as elements of a linked list as well as storing a reference to the XML node that corresponds to the fact. The parser will scan the entire document for facts, creating a linked list. This linked list is then traversed and each XML fact node is walked and processed so that each fact is represented by a dl_parser_fact_t object which contains the fact's literal.</p>
<p>The facts in the XML tree can be found by calling dl_parser_mappings as this will in turn walk the XML tree and call dl_parser_add_fact on all found facts. Found facts are then processed using dl_parser_process_fact. After processing the found facts can be found pointed to by the linked list head pointer dl_parser_fact_t* facts_head found within the dl_parser_doc_t object.</p>
<h2>Rule objects</h2>
<p>In Datalog rules are clauses that contain a body, the body being a potentially infinite length array of literals. In the XML parser rules are represented similarly to facts, using the dl_parser_rule_t object, with the exception that the rules object represents the body of the rule by an array of literal pointers. This list is dynamically allocated to allow for potentially infinite length rules. Parsing of rules happens in the same fashion as facts, in that a call to dl_parser_mappings will walk the XML tree and call dl_parser_add_rule on any found rules. These are then stores in a similar linked list fashion and processed through calls to dl_parser_process_rule whilst iterating over the linked list. The linked list of processed rules can be found using the head pointer dl_parser_rule_t* rules_head found in the dl_parser_doc_t object.</p>
<h2>Parser use</h2>
<p>Parser use should pretty much only require the user to call</p>
<div class="fragment"><div class="line"><a class="code" href="structdl__parser__doc.html">dl_parser_doc_t</a>* dl_doc = <a class="code" href="datalog__parser_8c.html#a60bfcc264ca417a3c86c24d83775126a">dl_parser_init</a>(filename);</div></div><!-- fragment --><p> followed by </p><div class="fragment"><div class="line"><a class="code" href="datalog__parser_8c.html#a83e01ba37291311f7b45d9eaa89bfd77">dl_parser_mappings</a>(dl_doc);</div></div><!-- fragment --><p>but one can also print any number of the objects in the library though the number of print functions. Document metadata can also be parsed by calling <a class="el" href="structdl__parser__metadata.html">dl_parser_metadata</a> which will populat a dl_parser_metadata_t object stored in the main dl_parser_doc_t object. See included example for furthur usage. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
